import JSZip from 'jszip'
import { sanitizeFileName } from './image-utils'
import type { ExportFile, ExportMetadata } from './image-types'

/**
 * ZIP packager for creating organized export archives
 */
export class ZipPackager {
    private zip: JSZip
    private metadata: ExportMetadata | null = null

    constructor() {
        this.zip = new JSZip()
    }

    /**
     * Add main content file to ZIP
     */
    addContentFile(
        fileName: string,
        content: string,
        _mimeType: string = 'text/plain',
    ): this {
        this.zip.file(fileName, content)
        return this
    }

    /**
     * Add image file to ZIP
     */
    addImageFile(
        relativePath: string,
        data: Blob | string,
        _mimeType?: string,
    ): this {
        this.zip.file(relativePath, data)
        return this
    }

    /**
     * Add multiple files at once
     */
    addFiles(files: ExportFile[]): this {
        files.forEach((file) => {
            this.zip.file(file.path, file.data)
        })
        return this
    }

    /**
     * Set export metadata
     */
    setMetadata(metadata: ExportMetadata): this {
        this.metadata = metadata
        return this
    }

    /**
     * Add metadata file to ZIP
     */
    private addMetadataFile(): this {
        if (this.metadata) {
            const metadataJson = JSON.stringify(this.metadata, null, 2)
            this.zip.file('metadata.json', metadataJson)
        }
        return this
    }

    /**
     * Add README file with export information
     */
    private addReadmeFile(): this {
        if (this.metadata) {
            const readme = this.generateReadmeContent()
            this.zip.file('README.txt', readme)
        }
        return this
    }

    /**
     * Generate README content for the export
     */
    private generateReadmeContent(): string {
        if (!this.metadata) return ''

        const { exportDate, imageHandlingStrategy, totalImages, conversationTitle } = this.metadata

        let content = `ChatGPT Export - ${conversationTitle}\n`
        content += `${'='.repeat(50)}\n\n`
        content += `Export Date: ${exportDate}\n`
        content += `Image Handling: ${this.getStrategyDisplayName(imageHandlingStrategy)}\n`
        content += `Total Images: ${totalImages}\n\n`

        if (imageHandlingStrategy === 'separate_files') {
            content += `Image Organization:\n`
            content += `- Image files are stored in the 'images/' directory\n`
            content += `- Each image has a descriptive filename based on its context\n`
            content += `- Relative paths are used in content for portability\n\n`
        }
        else if (imageHandlingStrategy === 'text_marker') {
            content += `Image Handling:\n`
            content += `- Images have been replaced with text markers\n`
            content += `- Original image URLs are preserved in metadata.json\n\n`
        }
        else if (imageHandlingStrategy === 'embed_base64') {
            content += `Image Handling:\n`
            content += `- Images are embedded as base64 data within the content\n`
            content += `- Files are self-contained but may be larger\n\n`
        }

        content += `File Structure:\n`
        if (imageHandlingStrategy === 'separate_files') {
            content += `- Main content file with embedded image references\n`
            content += `- images/ directory containing actual image files\n`
            content += `- metadata.json with detailed export information\n`
            content += `- This README file\n\n`
        }
        else {
            content += `- Single file export with all content embedded\n`
            content += `- metadata.json with detailed export information\n`
            content += `- This README file\n\n`
        }

        content += `Usage:\n`
        content += `- Open the main content file in any text editor or markdown viewer\n`
        content += `- For images, ensure you have the 'images/' folder in the same directory\n`
        content += `- Refer to metadata.json for detailed image information\n\n`

        content += `Generated by ChatGPT Exporter\n`
        content += `For more information, visit the project repository`

        return content
    }

    /**
     * Get display name for image handling strategy
     */
    private getStrategyDisplayName(strategy: string): string {
        switch (strategy) {
            case 'embed_base64':
                return 'Embed as Base64'
            case 'text_marker':
                return 'Text Markers'
            case 'separate_files':
                return 'Separate Files'
            default:
                return strategy
        }
    }

    /**
     * Create ZIP archive with all added files
     */
    async generateZip(
        compressionLevel: number = 9,
    ): Promise<Blob> {
        // Add metadata and README files
        this.addMetadataFile()
        this.addReadmeFile()

        return this.zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: {
                level: compressionLevel,
            },
        })
    }

    /**
     * Get estimated file size before generation
     */
    getEstimatedSize(): number {
        let totalSize = 0

        // Add content files size (approximation)
        Object.keys(this.zip.files).forEach((fileName) => {
            const file = this.zip.files[fileName]
            if (file && !(file as any).dir) {
                // This is a rough estimation - actual size may vary
                totalSize += (file as any)._data?.uncompressedSize || 0
            }
        })

        // Add metadata and README
        if (this.metadata) {
            totalSize += JSON.stringify(this.metadata).length
            totalSize += this.generateReadmeContent().length
        }

        return totalSize
    }
}

/**
 * Convenience function to create a complete export ZIP
 */
export async function createExportZip(
    mainFileName: string,
    mainContent: string,
    imageFiles: ExportFile[] = [],
    metadata: ExportMetadata,
    mimeType: string = 'text/plain',
): Promise<Blob> {
    const packager = new ZipPackager()

    // Add main content file
    packager.addContentFile(mainFileName, mainContent, mimeType)

    // Add image files if any
    if (imageFiles.length > 0) {
        packager.addFiles(imageFiles)
    }

    // Set metadata and generate
    packager.setMetadata(metadata)

    return packager.generateZip()
}

/**
 * Generate ZIP file name with timestamp
 */
export function generateZipFileName(
    conversationTitle: string,
    strategy: string,
    timestamp?: Date,
): string {
    const date = timestamp || new Date()
    const dateStr = date.toISOString().split('T')[0] // YYYY-MM-DD
    const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '') // HHMMSS

    const sanitizedTitle = sanitizeFileName(conversationTitle).substring(0, 50)
    const strategyPrefixMap = {
        embed_base64: 'embedded',
        text_marker: 'markers',
        separate_files: 'separate',
    }
    const strategyPrefix = strategyPrefixMap[strategy as keyof typeof strategyPrefixMap] || strategy

    return `chatgpt-export-${strategyPrefix}-${sanitizedTitle}-${dateStr}-${timeStr}.zip`
}
